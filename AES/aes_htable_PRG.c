#include <stdio.h>

#include "aes.h"
#include "aes_htable_prg.h"
#include "../Util/prg3.h"
#include "../Util/share.h"

#define TSIZE 256 //16 for PRESENT


byte x_shares[160*(shares_N-1)]; //Shares of x used as part of pre-processing.  496 *(N2-1) fpr PRESENT
byte T[160*TSIZE]; //Size of pre-computed tables for 10*16=160 S-box calls for AES-128, 496*TSIZE for PRESENT.


byte y_shares[160*(shares_N - 2)];

byte Y3[40960]; // Y3 array, with 256*160=40960 size
byte T2[160*TSIZE];

//************Functions for Normal variant using robust PRG *******************


//*************off-line functions******

void loc_refresh_table_r(byte *Tp,byte a,int n,int ind,int count) //LR for lookup table using robust PRG for normal share
{
    unsigned int pre_val=count*(n-1)*(n-1)*TSIZE;


    for(int k=0;k<TSIZE;k++)
    {
		for(int i=1;i<n;i++)
		{
            unsigned int val=pre_val+(ind*(n-1)*TSIZE)+(k*(n-1))+(i-1); //randoms needed per shift + per column + per row
            byte tmp=get_robprg3(n,val);
            set_robprgcount3();
            Tp[k]=Tp[k] ^ tmp;
     	}


        if(ind>0) //recomputation
        {
            for(int i=1;i<n;i++)
            {
                int previous_val=pre_val+((ind-1)*(n-1)*TSIZE)+((k^a)*(n-1))+(i-1);
                byte tmp=get_robprg3(n,previous_val);
                Tp[k]=Tp[k] ^ tmp;
            }
        }

    }
}



void loc_refresh_table_r_inc(byte *Tp,byte a,int n,int ind,int count) //LR for lookup table using robust PRG for increasing shares.
{
    unsigned int pre_val=count*n*(n-1)*TSIZE/2;

    for(int k=0;k<TSIZE;k++)
    {
		for(int i=0;i<=ind;i++)
		{
		    int t= ind * (ind+1)/2;
            int val=pre_val+(t*TSIZE)+(k*(ind+1))+(i); //randoms needed per shift + per column + per row
            byte tmp=get_robprg3(n,val);
			set_robprgcount3();
			Tp[k]=Tp[k] ^ tmp;
     	}

        if(ind>0)
        {
            for(int i=0;i<ind;i++)
            {
                int t= (ind-1) * ind/2;
                int previous_val=pre_val+(t*TSIZE)+((k^a)*(ind))+(i);
                byte tmp=get_robprg3(n,previous_val);
                Tp[k]=Tp[k] ^ tmp;
            }
        }

    }
}


void shift_tab(byte a,byte *Tp,int count)//Shift the entries of lookup table (LUT) by x_i
{
	unsigned int j,temp,temp1;

	for(j=0;j<TSIZE;j++)
	{
		temp=count*TSIZE;
		temp1=j^a;
    Tp[j]=T[temp+temp1];
	}
}


void htable_r(int n,int count,int choice)//choice= 1 for normal 0 for increasing. LUT using robust PRG
{
  byte Tp[TSIZE];
  int i,k;

  for(k=0;k<TSIZE;k++)
     T[count*TSIZE+(k)]=sbox[k];

  for(i=0;i<(n-1);i++) // In pre-proessing, T will be shifted by n-1 shares.
  {
    shift_tab(x_shares[count*(shares_N-1)+i],Tp,count);

    if(choice==NPRG)
        loc_refresh_table_r(Tp,x_shares[count*(shares_N-1)+i],n,i,count);

    else if(choice==IPRG)
        loc_refresh_table_r_inc(Tp,x_shares[count*(shares_N-1)+i],n,i,count);


    for(k=0;k <TSIZE;k++)
      T[count*TSIZE+(k)]=Tp[k];

  }
}


//********************* Pre-processing of Table T ***************************


//*********online functions*********



//**************Normal variant htable**********

void read_htable_r(byte a,byte *b,int n,int count) //Online function to read T(x_n), robust PRG
{
  int pre_val=count*(n-1)*(n-1)*TSIZE;
  int val=pre_val+((n-2)*(n-1)*TSIZE)+((n-1)*a);

	b[0]=T[count*TSIZE+(a)];

    for(int j=1;j<n;j++)
        b[j]=get_robprg3(n,val+(j-1)); //recomputation of output masks of T(x_n)

    locality_refresh(b,n);
}


void subbyte_htable_r(byte *a,int n,int count)
{
    read_htable_r(a[n-1],a,n,count);
}

//**************Online: Increasing shares*************

void read_htable_inc_r(byte a,byte *b,int n,int count) // Read T(x_n) for increasing shares of robust PRG
{
    unsigned int pre_val=count*n*(n-1)*TSIZE/2;
    unsigned int t= ((n-2) *(n-1)*TSIZE)/2;
    unsigned int val=pre_val+t+(a*(n-1)); //randoms needed per shift + per column + per row

	b[0]=T[count*TSIZE+(a)];

   for(int j=0;j<=n-2;j++)
    b[j+1]=get_robprg3(n,val+j); //recomputation of n-1 masks of T(x_n)

  locality_refresh(b,n);
}


void subbyte_htable_r_inc(byte *a,int n,int count)
{
    read_htable_inc_r(a[n-1],a,n,count);
}

//************End of functions for robust PRG*******************


//**********************htable using multiple PRG**************


//************Functions for Normal variant using multi PRG*******************

void loc_refresh_table_m(byte *Tp,byte a,int n,int ind,int count) //LR for lookup table using randomness generated by multiple PRG
{
    unsigned int pre_val= count*TSIZE;
	int i,j,t;

    for(j=0;j<TSIZE;j++)
    {
		for(i=1;i<n;i++)
		{
			unsigned int val=ind*(n-1);

            if((pre_val+j)%2) //The polynomial evaluation runs for even values of count
               set_mprg_lr_count();

            byte tmp=get_mprg_lr(val+(i-1),n,pre_val+j);
            Tp[j]=Tp[j] ^ tmp;
     	}

        if(ind>0) //recomputation of n-1 columns from previous shift
        {
            for(i=1;i<n;i++)
            {
                unsigned int val=(ind-1)*(n-1);
                t=(j^a);
                byte tmp=get_mprg_lr(val+(i-1),n,pre_val+t);
                Tp[j]=Tp[j] ^ tmp;
            }
        }

    }
}



//************Functions for Increasing shares variant using multi PRG*******************

void loc_refresh_table_inc_m(byte *Tp,byte a,int n,int ind,int count)
{
	unsigned int pre_val= count*TSIZE;
    for(int k=0;k<TSIZE;k++)
    {
        for(int i=0;i<=ind;i++)
        {
            int val=(ind*(ind+1))/2;

            if((pre_val+k)%2) //The polynomial evaluation runs for even values of count
                set_mprg_lr_count();

            byte tmp=get_mprg_lr(val+i,n,pre_val+k);
            Tp[k]=Tp[k] ^ tmp;
        }

        if(ind>0)
        {
            for(int i=0;i<ind;i++)
            {
                int val=((ind-1)*ind)/2;
                byte tmp=get_mprg_lr(val+i,n,pre_val+(k^a));
                Tp[k]=Tp[k] ^ tmp;
            }
        }

    }
}


//**************LUT pre-processing using multiple PRG**********

void htable_m(int n,int count,int choice)//Choice 1 for normal PRG 0 for Increasing shares
{
    unsigned int j,i,t,temp;
    byte Tp[TSIZE];
    for(j=0;j<TSIZE;j++)
	{
		temp=count*TSIZE;
		T[temp+j]=sbox[j];
	}


    for(i=0;i<(shares_N-1);i++) // In pre-proessing, T will be shifted by n-1 shares.
    {

        t=count*(shares_N-1);
        temp=x_shares[t+i];

        shift_tab(temp,Tp,count);

        if(choice==NPRG)
            loc_refresh_table_m(Tp,temp,n,i,count);

        else if(choice==IPRG)
            loc_refresh_table_inc_m(Tp,temp,n,i,count);


		for(j=0;j<TSIZE;j++)
		{
            temp=count*TSIZE;
            T[temp+j]=Tp[j];
		}
  }
}

/******************Online functions: multiple PRG **********/

void read_htable_m(byte a,byte *b,int n,int count) //Normal variant
{
	unsigned int pre_val=count*TSIZE;
	unsigned int val=(n-2)*(n-1);
	b[0]=T[(count*TSIZE)+a];

	for(int j=1;j<n;j++)
		b[j]=get_mprg_lr(val+j-1,n,pre_val+a); //recomputation of n-1 output masks of T(x_n)

	locality_refresh(b,n);
}

void read_htable_inc_m(byte a,byte *b,int n,int count) //Increasing shares
{
    unsigned int pre_val=count*TSIZE;
    unsigned int val=((n-2)*(n-1))/2;

	b[0]=T[(count*TSIZE)+a];

    for(int j=1;j<n;j++)
			b[j]=get_mprg_lr(val+j-1,n,pre_val+a); //recomputation of n-1 output masks of T(x_n)

		locality_refresh(b,n);
}

void subbyte_htable_mprg(byte *a,int n,int count)
{
    read_htable_m(a[n-1],a,n,count);
}

void subbyte_htable_inc_mprg(byte *a,int n,int count)
{
    read_htable_inc_m(a[n-1],a,n,count);
}

//************End of functions for Increasing shares multi PRG*******************

/***************Pre-processing of 160 tables for AES**********/

void gen_t_forall(int n,int choice,int type) //Check for robust/multiple PRG
{
    unsigned int temp;
    byte a[shares_N-1];

   	for(int i=0;i<160;i++)
    {
		gen_rand(a,n-1);
		temp=i*(n-1);

        for(int j=0;j<(n-1);j++)
        {
            x_shares[temp+j]=a[j];

        }

        //printf("calling htable\n");
		if(type==MPRG)
           htable_m(n,i,choice);
		else if(type==RPRG)
           htable_r(n,i,choice);

    }

}


//************state shares*************


void subbytestate_share_prg(byte stateshare[16][shares_N],int n,void (*subbyte_share_call)(byte *,int,int),int round)
{
  unsigned int t,ind;

  for(int i=0;i<16;i++)
  {
	ind=16*round+i;
	t=ind*(shares_N-1);
    byte temp=0;

    for(int j=0;j<n-1;j++)
       temp=temp ^ stateshare[i][j] ^ x_shares[t+j];

    stateshare[i][n-1]=stateshare[i][n-1] ^ temp;
    subbyte_share_call(stateshare[i],n,ind);

  }

}

/***************************specific to third order**************************/
void refresh_mask_sni(byte y_cw[4])
{
   byte t[4];
   gen_rand(t,4);
   y_cw[0]=(y_cw[0]^t[0])^t[3];
   y_cw[1]=(y_cw[1]^t[1])^t[0];
   y_cw[2]=(y_cw[2]^t[2])^t[1];
   y_cw[3]=(y_cw[3]^t[3])^t[2];
 
}
void subbyte_htable_third(byte y[shares_N], int n, int ind, int choice)
{

	byte x4;
	
	unsigned int t2 = ind*TSIZE;
	x4 = y[n - 1];
    
	y[0] = T2[t2 + x4]; //y4
	
	
		unsigned int t1 = ind*(shares_N - 2);
		for (int i = 1; i < shares_N - 1; i++) //n=4, thus y0 and y1
		{
		y[i] = y_shares[t1 + i - 1]; //y1 y2
        }
	    y[n - 1] = Y3[t2 + x4];
	
	
	
   //refresh_mask_byte(n-1,y);
   //refresh_mask_byte_LR(y);
   //fullrefresh_sni(y);
  
   refresh_mask_sni(y);
   
    
}
void subbytestate_share_third(byte stateshare[16][shares_N], int n, void(*subbyte_share_call)(byte *, int, int, int), int round, int choice)
{
	unsigned int i, j;
	unsigned int t, ind;
  
	for (i = 0; i < 16; i++)
	{
		ind = 16*round + i;
		t = ind*(shares_N - 1);
		byte temp = 0;
		for (j = 0; j < n - 1; j++)
			temp = temp ^ stateshare[i][j] ^ x_shares[t + j];
    
	
		stateshare[i][n - 1] = stateshare[i][n - 1] ^ temp;
	
		subbyte_share_call(stateshare[i], n, ind, choice); 
	
	}

}
void htable_third(int n, int count, int choice)
{
	unsigned int j, i, t, t1, temp, temp1, k = 0;
	byte Tp[TSIZE], v[1], d, b;
    
	temp = count*TSIZE;
    
	t = count*(shares_N - 1);
	t1 = count*(shares_N - 2);
	temp1 = x_shares[t];
	for (j = 0; j < TSIZE; j++)
	{
		Tp[j] = sbox[j^temp1] ^ y_shares[t1]; //S[x+a]+y1
	}
	gen_rand(v, 1);
    
	d = (x_shares[t + 1] ^ v[0]) ^ x_shares[t + 2];
    
	for (j = 0; j < TSIZE; j++)
	{
		b = j ^ d;
		T2[temp + b] = (Tp[v[0] ^ j] ^ Y3[temp + b]) ^ y_shares[t1 + 1];  
	}
    
}
void gen_t_forall_third(int n, int choice)
{
	unsigned int i, j, temp1, temp2, temp3;
	byte a[shares_N - 1],  c[TSIZE], common;

	
	for (i = 0; i < 160; i++)
	{
		
		temp1 = i*(shares_N - 1);

		for (j = 0; j < (n - 1); j++)
		{
			x_shares[temp1 + j] = a[j]; //need for both the choices
     
		}
       
			byte b[shares_N - 2];
			
			gen_rand(b, n - 2);
		    temp2 = i*(shares_N - 2);
		    for (j = 0; j < (n - 1); j++)
		    {
				y_shares[temp2 + j] = b[j]; 
            
	     	}
		    gen_rand(c, TSIZE);
			temp3 = i*TSIZE;
			for (j = 0; j < TSIZE; j++)
			{
				Y3[temp3 + j] = c[j]; 
            
			}
			htable_third(n, i, choice);
	/*	
	if(i==0)
    {
        for(int j=0;j<256;j++)
        printf("%u ",T2[j]);
    printf("\n");
    }*/
		
        
	}

}
